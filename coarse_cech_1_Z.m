/////////////////////////////////////////////////////////////////////////////////////
// Here we construct the zeroth Cech differential for the presheaf defined by the first
// cohomlogy groups of preimage (under \pi) of the open sets in the cover \U of B.
///////////////////////////////////////////////////////////////////////////////////

// The open sets in the cover with non-trivial H^1 are:
// 1) open sets U_e associated to edges, homotopy equivalent to three copies of the wedge product of four circles.
// 2) open sets U_f associated to triangular faces. The cohomology of these investigated in Section five.
// The only intersections of open sets whose preimages have non-trivial H^1 are the intersection of an open set
// corresponding to an edge with one corresponding to a triangular face.

//Therefore the Cech differential has a left half (denoted LH), corresponding to the open sets associated
// with triangular faces, and a right half (denoted RH), whose columns correspond to open sets associated
// with edges. We first describe the left hand half of this matrix.
LH :=  Matrix(Z,240,0,[]);

// The matrix LH admits a block decomposition. Each block contains 8 rows and 12 columns.
// Each subblock is determined by a 2-dimensional face f and an edge e contained in f.
// There is an open set U_f associated with a 2-dimensional face and an open set U_e associated
// with the edge e of f. The preimage of the intersection of U_f and U_e consists of 8 circles.
// Rows of the corresponding 8x12 block are in bijection with these circles and each row records
// the class of the corresponding circle in the torsion free part of the first homology group
// of the preimage of U_f.

// The torsion free part of the first homology group of the preimage of U_f is generated by 12 elements.
// This generating set (descrbied in the attached documentation) divides into three groups of four elements. 
// Hence each 8x12 subblock of the matrix LH further decomposes into 3 blocks which contain 8 rows and 4 columns.
// In fact, these 8x4 subblocks are given (up to sign) by LH_I, LH_J, and LH_Z, as defined below.

LH_I := VerticalJoin(IdentityMatrix(Integers(),4),IdentityMatrix(Integers(),4));
LH_J := Matrix(Z,8,4,[<1,4,1>,<2,3,1>,<3,2,1>,<4,1,1>,<5,4,1>,<6,3,1>,<7,2,1>,<8,1,1>]);
LH_Z := Matrix(Z,8,4,[]);
LH_blocks := [LH_I,LH_J,LH_Z];

// Given a face f we order its vertices from lowest index to highest. The edges of f are assigned a 'place,
// the index of the vertex which is not contained in this edge. The order of the blocks LH_I, LH_J, and LH_Z
// depends on the place of the given edge e. The list gluing_table records the order of these blocks. For example
// if place = 1, we form the 8x12 block as matrix with blocks LH_Z, LH_I, and LH_J, in that order.

gluing_table := [[3,1,2],[1,3,2],[1,2,3]];

// We construct the left hand block matrix one block of columns at a time.
for f in [1..10] do

	// This is the column we are currently working on. Initially this column contains no rows.
	curr_col := Matrix(Z,0,12,[]);

	// Meets_23 stores pairs [f,e] where e is the index of an edge contained in the 
	// two-dimensional face with index f.
	for m in Meets_23 do
		
		// If m contains the 2-face corresponding to the current column we insert a non-zero block.
		if f eq m[1] then
		
			// We obtain the value 'place' of the given edge.
            deleted_vertex := [v : v in vertices_of_fs[f] | v notin vertices_of_es[m[2]]][1];
            place := Index(vertices_of_fs[f],deleted_vertex);
			
			// We use the function find_face_signs to obtain any necessary sign changes for the blocks
			// LH_I, and LH_J.
			signs := find_face_signs(f,m[2],place);
			LH_sign_I := DiagonalJoin(ScalarMatrix(4,signs[1][1]),ScalarMatrix(4,signs[2][1]))*LH_I;
			LH_sign_J := DiagonalJoin(ScalarMatrix(4,signs[1][2]),ScalarMatrix(4,signs[2][2]))*LH_J;

			// We form the 8x12 block LH_total by joining these three blocks, as described
			// by the triples stored in 'gluing_table'.
			LH_sign_blocks := [LH_sign_I,LH_sign_J,LH_Z];
			LH_total := HorizontalJoin(
							HorizontalJoin(LH_sign_blocks[gluing_table[place][1]],
									LH_sign_blocks[gluing_table[place][2]]),
										LH_sign_blocks[gluing_table[place][3]]);

			curr_col := VerticalJoin(curr_col,LH_total);
		else

			// If m does not contain the index f of the given two-dimensional face, we append a zero block.
			curr_col := VerticalJoin(curr_col,Matrix(Z,8,12,[]));
		end if;
	end for;

	// Now we join the current column to the the left half of the differential.
	LH := HorizontalJoin(LH,curr_col);

end for;	

///////////////////////////////////////////////////////

// We construct the right hand block matrix RH. We recall that this describes
// the restriction map from neighbourhoods of edges U_e, to intersections of 
// such open sets with open sets U_f corresponding to two-dimensional faces.

RH :=  Matrix(Z,240,0,[]);

// We recall that the first homology group of the pre-image of U_e is 12 dimensional.
// The generating set described in attached documentation divides into 3 groups of 4 elements.
// The first homology group of  preimage of the intersection of U_e and U_f is 8 dimensional and 
// a natural generating set divides into 2 groups of 4. Hence the 8x12 block of RH corresponding
// to the edge e and triangular face f decomposes into six 4x4 matrices. These 4x4 blocks are
// either
// 1) The 4x4 zero matrix,
// 2) the 4x4 identity matrix, or
// 3) the 4x4 scalar matrix with all diagonal entires equal to -1.
for e in [1..10] do
	curr_col := Matrix(Z,0,12,[]); 

	for m in Meets_23 do
		if e eq m[2] then

			// The function find_edge_matrix returns a 2x3 matrix with entires -1, 0, or +1.
			edge_mtx := find_edge_matrix(m[1],e);

			// We then form a block matrix by replacing each entry in edge_mtx by a 4x4 scalar matrix.
			block := VerticalJoin(
					HorizontalJoin(
						HorizontalJoin(ScalarMatrix(4,edge_mtx[1,1]),ScalarMatrix(4,edge_mtx[1,2])),
							ScalarMatrix(4,edge_mtx[1,3])),
					HorizontalJoin(
						HorizontalJoin(ScalarMatrix(4,edge_mtx[2,1]),ScalarMatrix(4,edge_mtx[2,2])),
							ScalarMatrix(4,edge_mtx[2,3])));
			curr_col := VerticalJoin(curr_col,block);
		else
			curr_col := VerticalJoin(curr_col,Matrix(Z,8,12,[]));
		end if;
	end for;

	RH := HorizontalJoin(RH,curr_col);
end for;

// We form the Cech differential by joining the left and right halves, together with
// the sign change (although we note that this will not affect the column span of this matrix).
Cech_H1 := HorizontalJoin(LH,ScalarMatrix(240,-1)*RH);

// We run some sanity checks on the matrix Cech_H1.
// Check that for each row of LH there are two columns with non-zero entries.
print "Check the matrix Cech_H1 contains the expected number of non-zero entries in each column and row.";
[ #[1 : j in [1..120] | LH[i,j] ne 0 ] : i in [1..240] ] eq [2 : i in [1..240]];

// Check that for each row of RH there is a unique column with a non-zero entry.
[ #[1 : j in [1..120] | RH[i,j] ne 0 ] : i in [1..240] ] eq [1 : i in [1..240]];

// Check that for each column of LH there are four columns with a non-zero entries.
[ #[1 : j in [1..240] | LH[j,i] ne 0 ] : i in [1..120] ] eq [4 : i in [1..120]];

// Check that for each column of RH there are two columns with a non-zero entries.
[ #[1 : j in [1..240] | RH[j,i] ne 0 ] : i in [1..120] ] eq [2 : i in [1..120]];
